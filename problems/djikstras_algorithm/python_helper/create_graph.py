import numpy as np
import networkx as nx
import random
import matplotlib.pyplot as plt
import argparse

def generate_graph(n, source_node=0, sink_node=None):
    """
    Generates a directed graph with n nodes, a source node, and a sink node.
    Edges between nodes will have positive weights.

    :param n: Number of nodes in the graph.
    :param source_node: The source node index.
    :param sink_node: The sink node index. If None, will set sink_node as the last node.
    :return: A directed graph with positive weights.
    """

    if sink_node is None:
        sink_node = n - 1  # Set the last node as the sink by default

    # Create a directed graph
    G = nx.DiGraph()

    # Add nodes to the graph
    G.add_nodes_from(range(n))

    # Add edges with random positive weights between nodes
    for i in range(n-1):
        for j in range(n):
            connect_edge = random.randint(1, 3) % 2 == 0
            if (connect_edge and i != j) or j == i + 1:  # No self-loops
                weight = random.randint(1, 10)  # Random weight between 1 and 10
                G.add_edge(i, j, weight=weight)

    return G, source_node, sink_node

def plot_graph(G, source_node, sink_node):
    """
    Plots the graph with source and sink nodes highlighted.

    :param G: The graph object.
    :param source_node: The source node index.
    :param sink_node: The sink node index.
    """
    pos = nx.spring_layout(G)  # Layout for node positions
    plt.figure(figsize=(10, 8))

    # Draw the graph with node labels and edge weights
    nx.draw(G, pos, with_labels=True, node_size=700, node_color="lightblue")
    labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

    # Highlight the source and sink nodes
    nx.draw_networkx_nodes(G, pos, nodelist=[source_node], node_color="green", node_size=800)
    nx.draw_networkx_nodes(G, pos, nodelist=[sink_node], node_color="red", node_size=800)

    # Show the plot
    plt.title(f"Graph with Source Node {source_node} and Sink Node {sink_node}")
    plt.savefig("python_helper/last_graph.png")
    plt.show()

def print_graph_info(G):
    """
    Iterates through each node in the graph and prints the node,
    the nodes it points to, and the corresponding edge weights.

    :param G: The directed graph object.
    """
    with open("python_helper/last_graph.txt", "w") as f:
        f.write(f"{len(G.nodes)}\n")
        for node in G.nodes:
            # Get the outgoing edges for the current node
            neighbors = list(G.neighbors(node))
            weights = []
            # Print the current node and the nodes it points to, along with the corresponding weights
            print(f"Node {node} points to:")
            for neighbor in neighbors:
                weight = G[node][neighbor]['weight']  # Access the weight of the edge
                weights.append(weight)
                print(f"  -> Node {neighbor} with weight {weight}")
            print()  # Blank line between nodes for better readability
            f.write(f"[{node}]; {neighbors}; {weights}\n")

def parse_args() -> dict:
    parser = argparse.ArgumentParser()

    parser.add_argument("--n", type=int, help="Number of nodes in the graph.")
    parser.add_argument("--generate_new_graph", action="store_true", help="Generate a new graph.")

    args = parser.parse_args()
    args_dict = vars(args)

    return args_dict

if __name__ == '__main__':
    args = parse_args()
    n = args['n']
    generate_new_graph = args['generate_new_graph']

    if generate_new_graph:
        G, source, sink = generate_graph(n)

        # Plot the generated graph
        plot_graph(G, source, sink)
        print_graph_info(G)
        print(f"A new graph with {n} nodes has been generated by 'create_graph.py'.")
    else:
        print("No new graph was generated by 'create_graph.py'.")